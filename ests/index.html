<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <!--Step 1 : Loading PixiJS -->
    <script src="https://pixijs.download/release/pixi.js"></script>
    <!-- <script src="js/pixi.min.js"></script> -->
    <title>ESTS - 电工仿真实训系统</title>
    <!-- 引入样式 -->
    <!-- <link href="https://cdn.bootcss.com/element-ui/1.4.3/theme-default/index.css" rel="stylesheet">
		<link rel="stylesheet" href="css/main.css"> -->
    <!-- 先引入 Vue -->
    <!-- <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
 -->
    <!-- 引入组件库 -->
    <!-- <script src="https://cdn.bootcss.com/element-ui/1.4.3/index.js"></script>

		<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
		<script src="https://cdn.bootcss.com/underscore.js/1.8.3/underscore-min.js"></script> -->
</head>

<body>
    <div id="ests" style="margin: auto;"><canvas id="simu"></canvas></div>
</body>
<script>
    console.log('PIXI Version：', PIXI.VERSION);

    const design_width = 1600;
    const design_height = 900;
    var stage_width = design_width;
    var stage_height = design_height;
    if (window.innerWidth / window.innerHeight > 16 / 9) {
        stage_width = (window.innerHeight - 20) / 9 * 16;
        stage_height = window.innerHeight - 20;
    } else {
        stage_width = window.innerWidth - 20;
        stage_height = (window.innerWidth - 20) / 16 * 9;
    }
    const app = new PIXI.Application({
        width: design_width,
        height: design_height,
        // antialias: true,
        // transparent: false,
        // resolution: window.devicePixelRatio || 1,
        view: document.getElementById('simu'),
        // backgroundColor: 0xdcdcdc
        backgroundColor: 0x2f4f4f
    });
    var clientBGColor = 0x2f4f4f;//color name:darkslategray
    //缩放舞台
    app.renderer.resize(stage_width, stage_height);
    app.stage.scale.set(stage_width / design_width, stage_height / design_height);


    //创建根容器root并添加到舞台
    const root = new PIXI.Container();
    app.stage.addChild(root);
    //端子列表
    var portsList = new Array();

    //创建标题文本并添加到应用的root：
    const titleBar = new PIXI.Container();
    root.addChild(titleBar);
    const title = new PIXI.Text('ESTS - 电工仿真实训系统');
    titleBar.addChild(title);

    title.style.fill = "white";
    title.style.fontFamily = "SimHei"; //黑体
    // title.style.fontFamily = "SimSun";//宋体
    title.style.fontSize = 48;
    title.style.padding = 5;
    //水平居中显示
    title.anchor.set(0.5, 0);
    title.x = design_width / 2;
    title.y = 10;

    //底部信息栏
    const statusBar = new PIXI.Container();
    statusBar.x = 5;
    statusBar.y = 855;
    root.addChild(statusBar);
    const msg = new PIXI.Text();
    msg.style.fill = 'white';
    statusBar.addChild(msg);

    msg.style.fontFamily = "SimSun";
    msg.style.padding = 5;
    msg.style.fontSize = 27;
    msg.text = '标题栏宽度：' + title.width + '：' + titleBar.width + ' ,高度：' + title.height + ',' + titleBar.height +
        '. 标题横坐标：' + title.x + ' ,纵坐标：' + title.y + ' 状态栏高度：' + statusBar.height + '. 状态文本宽度：' + msg.width + ' ,高度：' + msg
            .height + '.';

    //中部画布
    var client = new PIXI.Container();
    root.addChild(client);
    client.y = 50;
    client.x = 5;
    client.interactiveChildren = true;
    var drawing = false;//开始画线标志
    var start = null;
    var end = null;
    var lines = [];//存储所有的连线
    var line_segments = [];//存储两端子之间连线的线段
    var linePoints = [];//存储线段起点及转折点坐标,client坐标系,client.toLocal()
    var pencil = new PIXI.Graphics();
    pencil.lineStyle(2, 0xFFFFFF, 2);
    var onPortClicked = false;

    //画布背景（client事件响应区）
    pencil.beginFill(clientBGColor);
    // pencil.beginFill(0xffffff);
    // pencil.beginFill(0xdcdcdc);
    let clientBG = pencil.drawRect(0, 0, design_width - 10, design_height - 100);
    pencil.endFill();
    client.addChild(clientBG);

    let pen = new PIXI.Graphics();
    pen.lineStyle(2, 0xdcdcdc, 2);
    // let c = pen.drawRect(client.toLocal({ 'x': client.width, 'y': client.height }).x - 10, client.toLocal({ 'x': client.width, 'y': client.height }).y - 10, 15, 15);
    let c = pen.drawRect(client.width - 1000, client.height.y - 500, 15, 15);
    console.log(client.toLocal({ 'x': client.width, 'y': client.height }), { 'x': client.width, 'y': client.height });
    client.addChild(c);



    //元件构造函数：el{name,text,img,hot,scale,x,y}元件，元件符号，图片，是否响应事件，缩放，x相对坐标，y相对坐标
    const Element = function (el, parentContainer) {
        this._name = el.name;
        this._parentContainer = parentContainer || client;
        //元件容器：
        this._container = new PIXI.Container();
        this._parentContainer.addChild(this._container);

        //元件在父容器中的位置坐标：
        this._x = el.x || 0;
        this._y = el.y || 0;
        this._container.x = this._x;
        this._container.y = this._y;
        //元件符号：
        this._text = new PIXI.Text(el.text);
        this._text.style.fill = 'white';
        this._text.style.fontSize = 20;
        this._container.addChild(this._text);
        //元件图片：
        this._sprite = PIXI.Sprite.from(el.img);

        this._container.addChild(this._sprite);
        this._scale = el.scale || 1;
        console.log('\t', this._name);
        this._sprite.scale.set(this._scale, this._scale);

        //符号与图片的位置：
        this._text.anchor.set(0.5, 0);
        this._text.x = this._sprite.width / 2;
        this._text.y = 0;
        this._sprite.x = 0;
        this._sprite.y = this._text.height + 2;
        // this._sprite.pivot.set(this._sprite.width/2, this._sprite.height/2);
        //元件边框
        this._box = new PIXI.Graphics();
        this._box.lineStyle(2, 0xFFFFFF, 2);
        this._box.drawRect(this._sprite.x, this._sprite.y, this._sprite.width, this._sprite.height);
        this._container.addChild(this._box);
        this._box.visible = false;

        //事件处理：
        this._hot = el.hot || false;
        if (this._hot) {
            this._sprite.eventMode = 'static';//'passive'：不响应；'static':响应 冒泡；'dynamic'：响应 冒泡

            //悬停时在端子图形上显示边框
            this._sprite.addEventListener('pointerover', () => {
                this._box.visible = true;
            });

            //光标移出时擦除边框
            this._sprite.addEventListener('pointerout', () => {
                this._box.visible = false;
            });

            //点击端子图片时开始或终止连线：首次点击开始，二次点击自身取消划线，二次点击目标为其他端子终止划线
            this._sprite.addEventListener('pointertap', (e) => {
                console.log(this._sprite.name, 'POINTERTAP:')
                onPortClicked = true;//阻止冒泡 点击端子时置true，点击其他位置是为false
                if (drawing) {

                    drawing = false;//中/终止画线
                    client_drawing = false;
                    if (e.target == start) {//起点终点相同 中止画线 删除已画线段
                        start = null;
                        linePoints = [];
                        line_segments.forEach(line_seg => {
                            client.removeChild(line_seg);
                        });
                        line_segments = [];
                        return;//注:return false 并不能阻止事件冒泡
                    } else {//起点终点不同 终止画线
                        end = e.target;

                        const pencil = new PIXI.Graphics();
                        pencil.lineStyle(2, 0xFFFFFF, 2);
                        //连线：
                        let line_seg = line_segments.pop();
                        client.removeChild(line_seg);
                        let seg_start;
                        [seg_start] = linePoints.slice(-1);
                        pencil.moveTo(seg_start.x, seg_start.y);
                        pencil.lineTo(client.toLocal(end.toGlobal(end.position)).x + end.width / 2, client.toLocal(end.toGlobal(end.position)).y);
                        //显示线段
                        client.addChild(pencil);
                        //存储线段
                        line_segments.push(pencil);
                        lines.push(line_segments);
                        //准备下次画线
                        client_drawing = false;
                        linePoints = [];
                        line_segments = [];
                        linePoints = [];
                        return;
                    }
                } else {
                    drawing = true;//开始画线
                    start = e.target;
                    linePoints.push({ 'x': client.toLocal(start.toGlobal(start.position)).x + start.width / 2, 'y': client.toLocal(start.toGlobal(start.position)).y });
                }

            });
        }

    }
    //端子组
    const PortsGroup = function (name, el, parentContainer) {
        this._name = name;
        console.log('创建PortsGroup:' + this._name);

        this._parentContainer = parentContainer || client;//默认加载到client容器

        this._ports = [];

        this._container = new PIXI.Container();
        this._parentContainer.addChild(this._container);

        this._portsW = 0;//端子总宽度
        this._portsH = 0;//端子总高度
        //下边框及文字符号
        //下边框位置
        this._linePad = 5
        this._lineX = 0;
        this._lineY = 0;
        this._lineW = 0;
        this._lineH = 5;
        //文字符号位置
        this._text = new PIXI.Text(this._name);
        this._container.addChild(this._text);
        this._text.style.fill = 'white';
        this._text.style.fontSize = 20;
        this._text.anchor.set(0.5, 0);
        this._textX = this._portsW / 2 - this._text.width / 2;
        this._textY = this._portsH + this._text.height;
        //用于画下边框的画笔
        this._graphics = new PIXI.Graphics();
        this._graphics.lineStyle(1, 0xffd900, 4);

        this._container.addChild(this._graphics);
        //
        this._draw = () => {
            console.log('\t绘制符号', this._name);
            //端子组符号：
            this._text.style.fill = 'white';
            this._text.style.fontSize = 20;
            this._text.anchor.set(0.5, 0);
            this._textX = this._container.width / 2 - this._text.width / 2;//居中
            this._textY = this._portsH + 5;
            this._text.x = this._textX;
            this._text.y = this._textY;
            console.log('\t绘制符号', this._name, '位置：', this._textX, this._textY);
            console.log('\tportsW:', this._portsW, 'containerW:', this._container.width);
            console.log('\t绘制下边框');
            //重绘下边框
            this._container.removeChild(this._graphics);
            this._graphics = new PIXI.Graphics();
            this._graphics.lineStyle(1, 0xffd900, 4);
            this._graphics.moveTo(15, this._textY + this._text.height / 2);
            this._graphics.lineTo(15, this._textY + this._text.height + 2);
            this._graphics.lineTo(this._portsW - 25, this._textY + this._text.height + 2);
            this._graphics.lineTo(this._portsW - 25, this._textY + this._text.height / 2);
            console.log('\tlength:', this._portsW - 25 - 15, 'height:', this._textY + this._text.height + 2 - (this._textY + this._text.height / 2));
            console.log('\t起点：', 15, ',', this._textY + this._text.height + 2, '终点', this._portsW - 25, ',', this._textY + this._text.height + 2)
            this._container.addChild(this._graphics);
        };

        //端子：
        let xPos = 0;
        let i = 0;
        el.forEach((port) => {
            console.log('\t=' + port.name);
            let p = new Element(port, parentContainer);
            this._ports.push(p._container);
            this._container.addChild(p._container);
            this._portsW += p._container.width;
            this._portsH = p._container.height;
            xPos += i * p._container.width;
            i++;
            p.x = xPos;
            console.log('\t----Pos:' + port.x + ',' + port.y, 'portsW', this._portsW, 'Continer w:', this._container.width, 'h:', this._container.height);
            // this._container.dispatchEvent(PortAddedEvent);
        });

        this._draw();

        console.log('\tContiner w:', this._container.width, 'h:', this._container.height);

        this.addPort = function (portJSON) {
            console.log('addPort:' + portJSON.name);
            let p = new Element(portJSON, parentContainer);
            this._ports.push(p._container);
            let xPos = this._container.width + p._container;
            this._container.addChild(p._container);
            p.x = xPos;
            console.log('\tPos:' + port.x + ',' + port.y);
            this._draw();
        }
        // this._draw();

    }
    //元件组
    function ElementsGroup(info, parentContainer) {
        this._parentContainer = parentContainer || client;
        this._name = info.name;
        this._text = info.text;
        console.log('+ ElementGroup:' + this._name);
        this._container = new PIXI.Container();
        this._parentContainer.addChild(this._container);
        this._elements = new Array();
        this.addElement = function (el) {
            let element = new Element(el, this._container);
            this._elements.push(element);
        }
    }
    let qf1 = new ElementsGroup({
        'name': '断路器 QF1',
        'text': 'QF1'
    }, client);
    //电源
    qf1.addElement({
        'name': '断路器 SQ1',
        'text': 'QF1',
        //'parent': client,
        'img': 'img/断路器-3p-OFF.png',
        'x': 0,
        'y': 100,
        // 'scale': 0.7
    });


    let qf2 = new ElementsGroup({
        'name': '断路器 QF2',
        'text': 'QF2'
    }, client);
    qf2.addElement({
        'name': '断路器 SQ2',
        'text': 'QF2',
        //'parent': client,
        'img': 'img/断路器-2p-OFF.png',
        'x': 169,
        'y': 100,
        // 'scale': 0.7
    });


    //电源进线端:

    //QF1进线端
    let qf1_in = new PortsGroup('QF1', [{
        'name': '电源进线端 L1',
        'text': '1',
        'parent': client,
        'img': 'img/端子_黄色.png',
        'x': 0,
        'y': 0,
        'hot': true
    }, {
        'name': '电源进线端 L2',
        'text': '3',
        'parent': client,
        'img': 'img/端子_绿色.png',
        'x': 60,
        'y': 0,
        'hot': true
    }, {
        'name': '电源进线端 L3',
        'text': '5',
        'parent': client,
        'img': 'img/端子_红色.png',
        'x': 120,
        'y': 0,
        'hot': true
    }], client);

    //QF1出线端
    let qf1_out = new PortsGroup('QF1', [{
        'name': '电源出线端 L1',
        'text': '2',
        'parent': client,
        'img': 'img/端子_黄色.png',
        'x': 0,
        'y': 380,
        'hot': true
    }, {
        'name': '电源出线端 L2',
        'text': '4',
        'parent': client,
        'img': 'img/端子_绿色.png',
        'x': 60,
        'y': 380,
        'hot': true
    }, {
        'name': '电源出线端 L3',
        'text': '6',
        'parent': client,
        'img': 'img/端子_红色.png',
        'x': 120,
        'y': 380,
        'hot': true
    }], client);

    //QF2进线端
    let qf2_in = new PortsGroup('QF2', [{
        'name': '电源进线端 L',
        'text': '1',
        'parent': client,
        'img': 'img/端子_红色.png',
        'x': 200,
        'y': 0,
        'hot': true
    }, {
        'name': '电源进线端 N',
        'text': '3',
        'parent': client,
        'img': 'img/端子_蓝色.png',
        'x': 260,
        'y': 0,
        'hot': true
    }], client);

    //QF2出线端
    let qf2_out = new PortsGroup('QF2', [{
        'name': '电源出线端 L',
        'text': '2',
        'parent': client,
        'img': 'img/端子_红色.png',
        'x': 200,
        'y': 380,
        'hot': true
    }, {
        'name': '电源出线端 N',
        'text': '4',
        'parent': client,
        'img': 'img/端子_蓝色.png',
        'x': 260,
        'y': 380,
        'hot': true
    }], client);


    //事件处理：
    //根据窗口调整画布大小，缩放舞台、
    window.addEventListener('resize', () => {
        // console.log("Window onresize!")
        if (window.innerWidth / window.innerHeight > 16 / 9) {

            stage_width = (window.innerHeight - 20) / 9 * 16;
            stage_height = window.innerHeight - 20;
        } else {
            stage_width = window.innerWidth - 20;
            stage_height = (window.innerWidth - 20) / 16 * 9;
        }
        app.renderer.resize(stage_width, stage_height);
        app.stage.scale.set(stage_width / design_width, stage_height / design_height);

        msg.text = '标题文本宽度：' + title.width + ' ,高度：' + title.height + ' 横坐标：' + title.x + ' ,纵坐标：' + title
            .y;
    });

    //退出页面：
    window.addEventListener("unload", () => app.destroy(true));

    //
    // app.stage.interactive = true;
    app.stage.hitArea = app.screen;

    //画布事件响应：
    // client.interactive = true;//过时写法
    // client.eventMode = 'none';//初始化 关闭画布事件响应，关闭后子显示对象也不响应事件
    client.eventMode = 'static';
    //跟随画线
    var client_drawing = false;//跟随画线标志，已经画了一条线
    client.addEventListener('pointermove', (e) => {
        // console.log('\npointmove:')
        if (!drawing) return;

        if (client_drawing) {//已经跟随鼠标画出了一条临时线，删掉
            let line_seg = line_segments.pop();
            client.removeChild(line_seg);
        }
        else {
            client_drawing = true;
        }
        //跟随画线：临时线，终点不保存        
        let seg_start = null;
        [seg_start] = linePoints.slice(-1);
        let line_seg = new PIXI.Graphics();
        line_seg.lineStyle(2, 0xFFFFFF, 2);
        line_seg.moveTo(seg_start.x, seg_start.y);//从上一条正式线段终点开始画
        line_seg.lineTo(client.toLocal(e.data).x, client.toLocal(e.data).y);//画到鼠标位置
        client.addChild(line_seg);
        line_segments.push(line_seg);//保存线段对象，以便删除
    });
    //点击划线
    client.addEventListener('pointertap', (e) => {
        // console.log('POINTERTAP:点击', e);
        if (!drawing) {
            console.log('刚才点击了，我接到了通知，但是没开始画线，所以我啥也不干。嘿嘿...');
            return;
        }

        if (onPortClicked) {
            onPortClicked = false;//阻止冒泡尝试 点击端子时置true，点击其他位置是为false
            console.log('刚才点击了端子，我接到了通知，但我啥也不干哈。嘿嘿...');
            return;
        }
        console.log('我收到通知，你点击了绘图区，这次我要做点什么...点击位置：' + Math.ceil(client.toLocal(e.data).x) + ',' + Math.ceil(client.toLocal(e.data).y) + ';client:W', client.width + ', H ' + client.height, 'pointer:', e.data.x + ',' + e.data.y)

        if (client_drawing) {//已经开始跟随画线某条线段
            let line_seg = line_segments.pop();
            client.removeChild(line_seg);
        }
        else {//跟随画线仅有起点
            client_drawing = true;
        }
        let seg_start = null;
        [seg_start] = linePoints.slice(-1);
        let line_seg = new PIXI.Graphics();
        line_seg.lineStyle(2, 0xFFFFFF, 2);
        line_seg.moveTo(seg_start.x, seg_start.y)
        line_seg.lineTo(client.toLocal(e.data).x, client.toLocal(e.data).y);
        client.addChild(line_seg);
        line_segments.push(line_seg);//保存线段对象，以便删除
        linePoints.push({ 'x': client.toLocal(e.data).x, 'y': client.toLocal(e.data).y });//保存正式线段的终点
        client_drawing = false;//为开始一条新的线段准备
    });

</script>

</html>